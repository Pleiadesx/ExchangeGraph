{"version":3,"sources":["features/chart/priceDataSlice.ts","app/hooks.ts","features/chart/cell/MarketCell.tsx","features/chart/cell/ExchangeCell.tsx","features/chart/util.ts","features/chart/Chart.tsx","App.tsx","app/store.ts","serviceWorker.ts","index.tsx","config.ts","features/chart/dataApi.ts"],"names":["DisplayMode","useAppSelector","useSelector","initialState","exchangeInfoStore","data","history","displayMode","TWO_BY_TWO","dataLimit","createPriceFrame","incomingPriceFrame","oneCoinBuyPrice","oneCoinSellPrice","isExchangeInfoRecorded","frame","state","exchangeId","connectToRSocket","createAsyncThunk","a","url","mimeType","client","RSocketClient","transport","RSocketWebSocketClient","wsCreator","u","WebSocket","BufferEncoders","setup","dataMimeType","metadataMimeType","keepAlive","lifetime","errorHandler","e","console","log","connect","sock","fetchDataFrames","endpoint","perMin","getState","rejectWithValue","dispatch","undefined","rsocket","priceData","dataSocket","getRequestStream","subscribe","onSubscribe","s","setInterval","request","onNext","priceFrame","oneCoinPriceFrameFromJsonString","processFrameReceived","onError","actions","priceDataSlice","createExchangeInfoPlaceholder","getExchangeInfoRequest","exchangeInfo","updateExchangeInfo","id","info","createSlice","name","reducers","action","payload","getExchangeInfoPlaceholder","updateDataLimit","extraReducers","builder","addCase","fulfilled","historyFrame","market","push","length","shift","dataFrame","Array","rsocketSelector","dataSelector","historySelector","exchangeInfoStoreSelector","buyPricesColor","sellPricesColor","highlightedColor","formatMarketId","marketId","charAt","toUpperCase","toLowerCase","slice","LineChartFromHistory","ITEMS","title","color","dataBuy","map","v","idx","x","y","dataSell","Row","Col","xs","margin","left","width","height","curve","items","MarketHeader","marketLogoUrl","marketUrl","href","Image","style","src","roundedCircle","className","MarketCell","price","highlighted","buy","sell","logoUrl","Card","text","Header","Body","background","currencyFormatter","format","ExchangeHeader","exchangeLogoUrl","exchangeUrl","exchangeName","ExchangeCell","marketRecord","historyRecord","minBuy","maxSell","Object","entries","sort","e1","e2","localeCompare","padding","marketLogoUrls","marketUrls","getAbsoluteReduced","exchangeData","reducerFunc","getterFunc","reduce","acc","innerReduced","accIn","filter","Chart","useDispatch","useEffect","rsocketUrl","priceFramesEndpoint","n1","n2","Math","min","max","Container","fluid","App","store","configureStore","reducer","priceDataReducer","middleware","getDefaultMiddleware","serializableCheck","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message","process","PORT","apiExchangeInfoEndPoint","Intl","NumberFormat","currency","requestStream","metadata","encodeAndAddWellKnownMetadata","Buffer","alloc","MESSAGE_RSOCKET_ROUTING","from","String","fromCharCode","json","JSON","parse","coinType","bestBuyPrice","bestSellPrice","fetch","res"],"mappings":"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","file":"static/js/main.1631b66a.chunk.js","sourcesContent":["import {BufferEncoders, RSocketClient} from \"rsocket-core\"\r\nimport {\r\n    createAsyncThunk,\r\n    createSlice,\r\n    PayloadAction\r\n} from \"@reduxjs/toolkit\";\r\n\r\n\r\nimport {\r\n    RootState,\r\n } from \"../../app/store\";\r\nimport { ReactiveSocket } from 'rsocket-types'\r\nimport { getExchangeInfoPlaceholder, getExchangeInfoRequest, getRequestStream, oneCoinPriceFrameFromJsonString } from \"./dataApi\";\r\nimport { Dispatch } from \"react\";\r\nimport RSocketWebSocketClient from \"rsocket-websocket-client\";\r\n\r\n\r\n\r\n\r\nexport interface IncomingPriceFrame {\r\n    market: string,\r\n    exchangeId: string,\r\n    oneCoinBuyPrice: number,\r\n    oneCoinSellPrice: number\r\n}\r\n\r\nexport interface PriceFrame {\r\n    oneCoinBuyPrice: number,\r\n    oneCoinSellPrice: number\r\n}\r\n\r\nexport interface ExchangeInfo {\r\n    exchangeName: string,\r\n    exchangeLogoUrl: string,\r\n    exchangeUrl: string,\r\n    marketUrls: Record<MarketId, string>,\r\n    marketLogoUrls: Record<MarketId, string>,\r\n}\r\n\r\nexport enum DisplayMode {\r\n    TWO_BY_TWO\r\n}\r\n\r\nexport type ExchangeId = string\r\nexport type MarketId = string\r\n\r\n\r\n\r\nexport interface PriceDataState {\r\n    exchangeInfoStore: Record<ExchangeId, ExchangeInfo>\r\n    data: Record<ExchangeId, Record<MarketId, PriceFrame>>,\r\n    history: Record<ExchangeId, Record<MarketId, Array<PriceFrame>>>,\r\n    dataSocketClient?: RSocketClient<any, any>,\r\n    dataSocket?: ReactiveSocket<any, any>,\r\n    displayMode: DisplayMode,\r\n    dataLimit: number\r\n}\r\n\r\n\r\nconst initialState: PriceDataState = {\r\n    exchangeInfoStore: {},\r\n    data: {},\r\n    history: {},\r\n    displayMode: DisplayMode.TWO_BY_TWO,\r\n    dataLimit: 100\r\n}\r\n\r\nfunction createPriceFrame(incomingPriceFrame: IncomingPriceFrame) : PriceFrame {\r\n    return {\r\n        oneCoinBuyPrice: incomingPriceFrame.oneCoinBuyPrice,\r\n        oneCoinSellPrice: incomingPriceFrame.oneCoinSellPrice\r\n    }\r\n}\r\n\r\nconst isExchangeInfoRecorded = (\r\n    frame: IncomingPriceFrame,\r\n    state: PriceDataState) => {\r\n\r\n    return frame.exchangeId in state.exchangeInfoStore;\r\n}\r\n\r\n\r\nfunction processExchangeInfoReceived(state: PriceDataState, dispatch: Dispatch<any>) {\r\n\r\n}\r\n\r\n\r\nexport const connectToRSocket = createAsyncThunk<\r\n    ReactiveSocket<any, any>,\r\n    {url: string, mimeType?: string}\r\n>(\r\n    \"priceData/connectToRSocket\",\r\n    async ({url, mimeType = \"application/json\"}) => {\r\n        const client = new RSocketClient(\r\n            {\r\n                transport: new RSocketWebSocketClient(\r\n                    {\r\n                        url: url,\r\n                        wsCreator: u => new WebSocket(u)\r\n                    }, BufferEncoders\r\n                ),\r\n                setup: {\r\n                    dataMimeType: mimeType,\r\n                    metadataMimeType: \"message/x.rsocket.composite-metadata.v0\",\r\n                    keepAlive: 20000,\r\n                    lifetime: 60000\r\n                },\r\n                errorHandler: e => {console.log(e)}\r\n            }\r\n        )\r\n\r\n        const sock = await client.connect()\r\n        return sock\r\n    }\r\n)\r\n\r\nexport const fetchDataFrames = createAsyncThunk<\r\n    void,\r\n    {endpoint: string, perMin?: number},\r\n    {\r\n        state: RootState\r\n    }\r\n>(\r\n    \"priceData/FetchDataFrames\",\r\n    async ({endpoint, perMin = 1000}, {getState, rejectWithValue, dispatch}) => {\r\n        const rsocket = getState().priceData.dataSocket\r\n        if (rsocket !== undefined) {\r\n            getRequestStream(rsocket, endpoint)\r\n                .subscribe({\r\n\r\n                    onSubscribe: s => {\r\n                        setInterval(() => s.request(perMin))\r\n                        s.request(perMin)\r\n\r\n                    },\r\n                    onNext: e =>  {\r\n                        const priceFrame =oneCoinPriceFrameFromJsonString(e.data)\r\n                        dispatch(processFrameReceived(priceFrame))\r\n                    },\r\n                    onError: e => {\r\n                        console.log(e)\r\n                    }\r\n                })\r\n        }\r\n    }\r\n)\r\n\r\nexport const processFrameReceived = createAsyncThunk<\r\n    IncomingPriceFrame,\r\n    IncomingPriceFrame,\r\n    {\r\n        state: RootState\r\n    }\r\n>(\r\n    \"priceData/frameReceived\",\r\n    async (frame: IncomingPriceFrame, {getState, dispatch}) => {\r\n\r\n        const actions = priceDataSlice.actions\r\n        const state = getState()\r\n\r\n        if (!isExchangeInfoRecorded(frame, state.priceData)) {\r\n            // need to get exchange info and add it\r\n            dispatch(\r\n                actions\r\n                .createExchangeInfoPlaceholder(frame.exchangeId))\r\n\r\n            // get the info and dispatch\r\n            const exchangeInfo = await getExchangeInfoRequest(frame.exchangeId)\r\n            dispatch(actions.updateExchangeInfo({id: frame.exchangeId, info: exchangeInfo}))\r\n\r\n            // proccess the info returned\r\n            processExchangeInfoReceived(state.priceData, dispatch)\r\n\r\n        }\r\n\r\n\r\n        return frame;\r\n    }\r\n)\r\n\r\nexport const priceDataSlice = createSlice({\r\n    name: 'priceData',\r\n    initialState,\r\n    reducers: {\r\n        createExchangeInfoPlaceholder: (state, action: PayloadAction<ExchangeId>) => {\r\n            if (action.payload !in state.exchangeInfoStore){\r\n                state.exchangeInfoStore[action.payload] = getExchangeInfoPlaceholder(action.payload)\r\n            }\r\n        },\r\n        updateExchangeInfo: (state, action: PayloadAction<{id: ExchangeId, info: ExchangeInfo}>) => {\r\n            state.exchangeInfoStore[action.payload.id] = action.payload.info\r\n        },\r\n        updateDataLimit: (state, action: PayloadAction<number>) => {\r\n            state.dataLimit = action.payload\r\n        }\r\n    },\r\n    extraReducers: (builder) => {\r\n        builder.addCase(processFrameReceived.fulfilled,  (state, action) => {\r\n\r\n            if (!(action.payload.exchangeId in state.data)) {\r\n                // if the data frame has not been created add it\r\n                const dataFrame = createPriceFrame(action.payload)\r\n                const historyFrame = createPriceFrame(action.payload)\r\n\r\n                state.data[action.payload.exchangeId] = {\r\n                    [action.payload.market]: dataFrame\r\n                }\r\n\r\n                state.history[action.payload.exchangeId] = {\r\n                    [action.payload.market]: Array(historyFrame)\r\n                }\r\n\r\n\r\n            } else {\r\n                const priceFrame = createPriceFrame(action.payload)\r\n                const historyFrame = createPriceFrame(action.payload)\r\n                state.data[action.payload.exchangeId][action.payload.market] = priceFrame\r\n                if (action.payload.market in state.history[action.payload.exchangeId]) {\r\n                    state.history[action.payload.exchangeId][action.payload.market].push(historyFrame)\r\n                } else {\r\n                    state.history[action.payload.exchangeId][action.payload.market] = [historyFrame]\r\n                }\r\n\r\n                if (state.dataLimit > -1 &&\r\n                    state.history[action.payload.exchangeId][action.payload.market].length > state.dataLimit) {\r\n\r\n                        state.history[action.payload.exchangeId][action.payload.market].shift()\r\n                }\r\n\r\n            }\r\n\r\n        })\r\n        builder.addCase(connectToRSocket.fulfilled, (state, action) => {\r\n            console.log(\"connected to rsocket fulfilled\")\r\n            state.dataSocket = action.payload\r\n        })\r\n        builder.addCase(fetchDataFrames.fulfilled, (state, action) => {\r\n\r\n        })\r\n    }\r\n});\r\n\r\n\r\nexport const appSelectorValid = (state: RootState) => state.priceData.dataSocket !== undefined\r\nexport const rsocketSelector = (state: RootState) => state.priceData.dataSocket\r\nexport const dataSelector = (state: RootState) => state.priceData.data\r\nexport const historySelector = (state: RootState) => state.priceData.history\r\n\r\nexport const dataSelectorThunk = (exchangeId: ExchangeId, marketId: MarketId) => (state: RootState) =>\r\n    state.priceData.data[exchangeId]?.[marketId]\r\n\r\nexport const historySelectorThunk = (exchangeId: ExchangeId, marketId: MarketId) => (state: RootState) =>\r\n    state.priceData.history[exchangeId]?.[marketId]\r\n\r\nexport const exchangeInfoStoreSelector = (state: RootState) => state.priceData.exchangeInfoStore\r\n\r\n\r\nexport default priceDataSlice.reducer\r\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","\r\nimport { MarketId, PriceFrame } from '../priceDataSlice'\r\nimport Card from 'react-bootstrap/Card'\r\nimport 'bootstrap/dist/css/bootstrap.min.css'\r\n\r\nimport {Col, Row, Image} from 'react-bootstrap'\r\nimport {\r\n    HorizontalGridLines,\r\n    VerticalGridLines,\r\n    XAxis,\r\n    XYPlot,\r\n    YAxis,\r\n    LineSeries,\r\n    DiscreteColorLegend\r\n} from 'react-vis'\r\nimport { currencyFormatter } from '../../../config'\r\n\r\nconst buyPricesColor = \"#51ff97\"\r\nconst sellPricesColor = \"#ff2424\"\r\nconst highlightedColor = \"#545D69\"\r\n\r\n\r\nconst formatMarketId = (marketId: MarketId) => {\r\n\r\n    return marketId.charAt(0).toUpperCase() + marketId.toLowerCase().slice(1)\r\n}\r\n\r\n\r\nconst LineChartFromHistory = (history: PriceFrame[]) => {\r\n    if (history.length > 1) {\r\n\r\n\r\n\r\n        const ITEMS = [\r\n            {title: \"Buy Price\", color: buyPricesColor},\r\n            {title: \"Sell Price\", color: sellPricesColor}\r\n        ]\r\n        const dataBuy = history.map((v, idx) =>  {\r\n            return {x: idx, y: v.oneCoinBuyPrice}\r\n        })\r\n        const dataSell = history.map((v, idx) => {\r\n            return {x: idx, y: v.oneCoinSellPrice}\r\n        })\r\n        return (\r\n            <div>\r\n\r\n            <Row>\r\n            <Col xs={10}>\r\n            <XYPlot margin={{left: 100}} width={700} height={500}>\r\n                    <HorizontalGridLines/>\r\n                    <VerticalGridLines/>\r\n                    <XAxis/>\r\n                    <YAxis />\r\n                    <LineSeries\r\n                        curve={'curveMonotoneX'}\r\n                        data={dataBuy}\r\n                        color={buyPricesColor}\r\n                    />\r\n                    <LineSeries\r\n                        curve={'curveMonotoneX'}\r\n                        data={dataSell}\r\n                        color={sellPricesColor}\r\n                    />\r\n\r\n            </XYPlot>\r\n            </Col>\r\n            <Col>\r\n            <DiscreteColorLegend  items={ITEMS}/>\r\n            </Col>\r\n            </Row>\r\n\r\n            </div>\r\n        )\r\n\r\n    }\r\n}\r\nconst MarketHeader = (marketId: MarketId, marketLogoUrl?: string, marketUrl?: string) => {\r\n\r\n    if (marketLogoUrl === undefined) {\r\n        if (marketUrl === undefined || marketUrl.length === 0) {\r\n            return formatMarketId(marketId)\r\n        } else {\r\n            return (\r\n                <div>\r\n                    <a href={marketUrl}>{formatMarketId(marketId)}</a>\r\n                </div>\r\n            )\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <Image style={{width: 30, height: 'auto'}} src={marketLogoUrl} roundedCircle/>\r\n            {' '} <a href={marketUrl} className='market-cell-name'>{formatMarketId(marketId)}</a>\r\n        </div>\r\n    )\r\n\r\n\r\n}\r\n\r\ninterface MarketCellProps {\r\n    marketId: MarketId,\r\n    price: PriceFrame,\r\n    history: PriceFrame[],\r\n    highlighted?: {\r\n        buy?: boolean,\r\n        sell?: boolean\r\n    },\r\n    logoUrl?: string,\r\n    marketUrl?:string,\r\n}\r\n\r\nexport default function MarketCell(\r\n    {marketId,\r\n        price,\r\n        history,\r\n        highlighted = {buy: false, sell: false},\r\n        logoUrl,\r\n        marketUrl,\r\n    }: MarketCellProps\r\n) {\r\n\r\n\r\n    return (\r\n        <div>\r\n        <Card className='market-card' text='white'>\r\n            <Card.Header>\r\n                {MarketHeader(marketId, logoUrl, marketUrl)}\r\n            </Card.Header>\r\n            <Card.Body>\r\n                <Row>\r\n                <Col>\r\n                <div className=\"chart-buy-price\" style={\r\n\r\n                    highlighted?.buy ? {color: buyPricesColor, background: highlightedColor} :\r\n                    {color: buyPricesColor}\r\n                }>\r\n\r\n                Buy: {currencyFormatter.format(price.oneCoinBuyPrice)}\r\n\r\n                </div>\r\n                </Col>\r\n                <Col>\r\n                <div className=\"chart-sell-price\" style={\r\n                    highlighted?.sell ? {color: sellPricesColor, background: highlightedColor} :\r\n                    {color: sellPricesColor}\r\n\r\n                    }>\r\n                    Sell: {currencyFormatter.format(price.oneCoinSellPrice)}\r\n                </div>\r\n                </Col>\r\n                </Row>\r\n                {LineChartFromHistory(history)}\r\n            </Card.Body>\r\n        </Card>\r\n        </div>\r\n    )\r\n\r\n}\r\n","import { ExchangeInfo, MarketId, PriceFrame } from \"../priceDataSlice\";\r\nimport MarketCell from './MarketCell'\r\nimport Row from 'react-bootstrap/Row'\r\nimport { Card } from \"react-bootstrap\";\r\nimport Image from 'react-bootstrap/Image'\r\n\r\n\r\n\r\n\r\ninterface ExchangeCellProps {\r\n\r\n    exchangeInfo: ExchangeInfo | null,\r\n    marketRecord: Record<MarketId, PriceFrame>,\r\n    historyRecord: Record<MarketId, PriceFrame[]>\r\n    maxSell: Record<MarketId, number>,\r\n    minBuy: Record<MarketId, number>,\r\n\r\n}\r\n\r\nconst ExchangeHeader = (exchangeInfo: ExchangeInfo | null) => {\r\n\r\n    if (exchangeInfo != null) {\r\n        return (\r\n            <div>\r\n                <Image style={{width: 30, height: 'auto'}} src={exchangeInfo.exchangeLogoUrl} roundedCircle/>\r\n                {' '}\r\n                <a href={exchangeInfo?.exchangeUrl} className='exchange-cell-name'>\r\n                    {exchangeInfo?.exchangeName}\r\n                </a>\r\n            </div>\r\n        )\r\n    } else {\r\n        return ' '\r\n    }\r\n\r\n}\r\n\r\n\r\nexport default function ExchangeCell(\r\n    {exchangeInfo, marketRecord, historyRecord, minBuy, maxSell} : ExchangeCellProps\r\n) {\r\n\r\n\r\n\r\n    const highlighted = (marketId : MarketId, priceFrame: PriceFrame) => {\r\n        return {\r\n            buy: minBuy[marketId] ? minBuy[marketId] === priceFrame.oneCoinBuyPrice  : false,\r\n            sell: maxSell[marketId] ? maxSell[marketId] === priceFrame.oneCoinSellPrice : false\r\n        }\r\n    }\r\n\r\n\r\n    return (\r\n        <div>\r\n            <Card className=\"exchange-card\" text='white'>\r\n                <Card.Header>\r\n\r\n                    {ExchangeHeader(exchangeInfo)}\r\n\r\n                </Card.Header>\r\n                <Card.Body>\r\n            {Object.entries(marketRecord).sort((e1, e2) => e1[0].localeCompare(e2[0])).map(\r\n                ([marketId, priceFrame]) =>\r\n                    <Row style={{padding: 10}} key={marketId}>\r\n                    <MarketCell\r\n                        highlighted={highlighted(marketId, priceFrame)}\r\n                        marketId={marketId}\r\n                        price={priceFrame}\r\n                        history={historyRecord[marketId]}\r\n                        logoUrl={exchangeInfo?.marketLogoUrls?.[marketId]}\r\n                        marketUrl={exchangeInfo?.marketUrls?.[marketId]}\r\n                        />\r\n                    </Row>\r\n                )\r\n\r\n            }\r\n            </Card.Body>\r\n            </Card>\r\n        </div>\r\n    )\r\n\r\n}\r\n\r\n","import { ExchangeId, MarketId, PriceFrame } from \"./priceDataSlice\";\r\n\r\n\r\n\r\n\r\nexport function getAbsoluteReduced(\r\n    exchangeData: Record<ExchangeId, Record<MarketId, PriceFrame>>,\r\n    reducerFunc: (n1: number, n2: number) => number,\r\n    getterFunc: (frame: PriceFrame) => number,\r\n    ) {\r\n\r\n\r\n    return Object.entries(exchangeData).reduce<Record<MarketId, number>>(\r\n\r\n        (acc, [exchangeId, marketRecord]) => {\r\n\r\n            const innerReduced = Object.entries(marketRecord).reduce<Record<MarketId, number>>(\r\n                (accIn, [marketId, frame]) => {\r\n                    if (!(marketId in accIn)) {\r\n                        return {\r\n                            ...accIn,\r\n                            [marketId]: getterFunc(frame)\r\n                        }\r\n                    } else {\r\n                        return {\r\n                            ...accIn,\r\n                            [marketId]: reducerFunc(getterFunc(frame), accIn[marketId])\r\n                        }\r\n                    }\r\n                }, {}\r\n            )\r\n\r\n            return Object.entries(innerReduced).filter(\r\n                ([marketId, price]) => {\r\n                    return (!(marketId in acc) || reducerFunc(price, acc[marketId]) === price)\r\n                }\r\n            ).reduce(\r\n                (accIn, [marketId, price]) => {\r\n                    return {\r\n                        ...accIn,\r\n                        [marketId]: price\r\n                    }\r\n                }, acc\r\n            )\r\n\r\n        }, {}\r\n    )\r\n\r\n\r\n\r\n}\r\n\r\n\r\n","import {useEffect} from 'react'\r\nimport Container from 'react-bootstrap/Container'\r\nimport Row from 'react-bootstrap/Row'\r\nimport Col from 'react-bootstrap/Col'\r\n\r\n\r\nimport { useAppSelector, useAppDispatch } from '../../app/hooks'\r\nimport { priceFramesEndpoint, rsocketUrl } from '../../config'\r\n\r\nimport {\r\n    connectToRSocket,\r\n    rsocketSelector,\r\n    fetchDataFrames,\r\n    dataSelector,\r\n    historySelector,\r\n    exchangeInfoStoreSelector,\r\n} from './priceDataSlice'\r\nimport ExchangeCell from './cell/ExchangeCell'\r\nimport { getAbsoluteReduced } from './util'\r\n\r\n\r\n\r\nexport const Chart = () => {\r\n    const rsocket = useAppSelector(rsocketSelector)\r\n    const data = useAppSelector(dataSelector)\r\n    const history = useAppSelector(historySelector)\r\n    const exchangeInfoStore = useAppSelector(exchangeInfoStoreSelector)\r\n\r\n    const dispatch = useAppDispatch()\r\n\r\n    useEffect(() => {\r\n        if (rsocket === undefined) {\r\n            dispatch(connectToRSocket({url: rsocketUrl}))\r\n        }\r\n    })\r\n\r\n    useEffect(() => {\r\n        if (rsocket !== undefined) {\r\n            console.log(\"rsocket was valid\")\r\n            dispatch(fetchDataFrames({endpoint: priceFramesEndpoint}))\r\n        } else {\r\n            console.log(\"rsocket was not valid\")\r\n        }\r\n    }, [rsocket])\r\n\r\n\r\n    const minBuy = getAbsoluteReduced(\r\n        data,\r\n        (n1, n2) => Math.min(n1, n2),\r\n        (frame) => frame.oneCoinBuyPrice\r\n    )\r\n\r\n    const maxSell = getAbsoluteReduced(\r\n        data,\r\n        (n1, n2) => Math.max(n1, n2),\r\n        (frame) => frame.oneCoinSellPrice\r\n    )\r\n\r\n    return (\r\n        <div>\r\n            <Container fluid>\r\n                <Row>\r\n                {\r\n                    Object.entries(data).map(\r\n                        ([exchangeId, marketRecord]) =>\r\n                        <Col>\r\n                            <ExchangeCell key={exchangeId}\r\n                                maxSell={maxSell}\r\n                                minBuy={minBuy}\r\n                                exchangeInfo={\r\n                                    exchangeId in exchangeInfoStore ?\r\n                                    exchangeInfoStore[exchangeId] : null\r\n                                }\r\n                                marketRecord={marketRecord}\r\n                                historyRecord={history[exchangeId]}\r\n\r\n                            />\r\n                        </Col>\r\n                    )\r\n                }\r\n                </Row>\r\n            </Container>\r\n        </div>\r\n    )\r\n\r\n}\r\n\r\n","\nimport './App.css';\nimport { Chart } from './features/chart/Chart';\nimport 'bootstrap/dist/css/bootstrap.min.css'\nimport 'react-vis/dist/style.css'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Chart />\n    </div>\n  );\n}\n\nexport default App;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport priceDataReducer from '../features/chart/priceDataSlice';\n\nexport const store = configureStore({\n  reducer: {\n    priceData: priceDataReducer\n  },\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware({serializableCheck: false})\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","\r\n// hardcoding this for now\r\nexport const priceFramesEndpoint = \"api.prices.one_coin_stream\"\r\nexport const rsocketUrl = `ws://localhost:${process.env.PORT || 8080}/rsocket`\r\nexport const apiExchangeInfoEndPoint = \"/exchangeInfo/\"\r\nexport const currencyFormatter = new Intl.NumberFormat('en-us',\r\n    {\r\n        style:'currency',\r\n        currency: 'USD'\r\n    }\r\n);","import { ExchangeId, ExchangeInfo, IncomingPriceFrame } from \"./priceDataSlice\";\r\nimport {encodeAndAddWellKnownMetadata, MESSAGE_RSOCKET_ROUTING} from 'rsocket-core'\r\nimport {ReactiveSocket } from 'rsocket-types'\r\nimport { apiExchangeInfoEndPoint } from \"../../config\";\r\n\r\nexport function getExchangeInfoPlaceholder(exchangeId: ExchangeId) : ExchangeInfo {\r\n\r\n    return {\r\n        exchangeLogoUrl: \"\",\r\n        exchangeName: exchangeId,\r\n        exchangeUrl: \"\",\r\n        marketUrls: {},\r\n        marketLogoUrls: {}\r\n    }\r\n\r\n}\r\n\r\nexport const getRequestStream = (rsocket: ReactiveSocket<any, any>, endpoint: String) => {\r\n\r\n    return rsocket.requestStream(\r\n        {\r\n            metadata:\r\n                encodeAndAddWellKnownMetadata(\r\n                    Buffer.alloc(0),\r\n                    MESSAGE_RSOCKET_ROUTING,\r\n                    Buffer.from(String.fromCharCode(endpoint.length) + endpoint)\r\n                )\r\n        }\r\n    )\r\n\r\n}\r\n\r\n\r\nexport const oneCoinPriceFrameFromJsonString = (s: string) : IncomingPriceFrame => {\r\n\r\n    const json = JSON.parse(s)\r\n    return {\r\n        market: json.coinType,\r\n        exchangeId: json.exchangeId,\r\n        oneCoinBuyPrice: json.bestBuyPrice.price,\r\n        oneCoinSellPrice: json.bestSellPrice.price\r\n    }\r\n\r\n\r\n}\r\n\r\nexport async function getExchangeInfoRequest(exchangeId: ExchangeId) : Promise<ExchangeInfo> {\r\n\r\n    try {\r\n        const res = await fetch(apiExchangeInfoEndPoint + exchangeId)\r\n        const json = await res.json()\r\n        return {\r\n            exchangeName: json.exchangeName,\r\n            exchangeLogoUrl: json.exchangeLogoUrl,\r\n            exchangeUrl: json.exchangeUrl,\r\n            marketUrls: json.marketUrls,\r\n            marketLogoUrls: json.marketLogoUrls,\r\n        }\r\n\r\n    } catch (e) {\r\n        console.log(\"error: \")\r\n        console.log(e)\r\n        return getExchangeInfoPlaceholder(exchangeId)\r\n    }\r\n\r\n}\r\n\r\n"],"sourceRoot":""}